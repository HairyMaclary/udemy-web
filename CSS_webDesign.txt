**********************************************************


CSS and Web Design


**********************************************************

- Intro and Box Rendering Objects
- CSS Syntax
- How to use a Style Sheet
- Position
- Display
- Border
- width
- height
- Alignment
- div
- Float
- Buttons
- px vs %
- Links
- Flexbox
- NavBar example
- Toolbar Example
- Side Draw Example
- Modals in React
- Using Media Queries to Disable an Element
- Lists
- Pseudo-elements generated by ::before and ::after
- Typography
- Color
- Working with Images
- Working with Icons
- Whitespace
- Define Your Project
- Responsive Web Design
- Quotes



Intro and Box Rendering Objects
------------------------------------------------


CSS stands for Cascading Style Sheets. 

CSS describes how HTML elements are to be displayed on screen, paper, or in other media, and is generally stored in .css files. 

Each node in the document tree generates zero or more 'rendering objects'. A rendering object is defined by a set of CSS properties. There are three types of rendering objects, one of which is the box, which is ment for screens. Boxes are rectangular objects with padding, borders, and margins. https://www.w3.org/TR/WD-CSS2-971104/box.html

Each box has a core content area (e.g., text, an image, etc.) and optional surrounding padding, border and margin areas. There are no properties to set the color of margins and padding; margins are always transparent and padding areas always uses the background of the element itself.

The total width of the box (resp., height) of the box is given by the sum of the content width (resp., height), the padding, the border, and the margin. The size of the margin, border and padding are set with the margin, padding, and border properties, respectively. However the css width property of the element is, by default, only the width of the content. It is not the total width. Likewise, the height of the element is the height of the content, i.e., the distance from inner top to inner bottom (see more in the width section). If box-sizing is set to border-box, however, it instead determines the width of the border area.

Margin properties are used to create space around elements, outside of any defined borders. Possible values are <length> | <percentage> | auto | inherit. Auto horizontally centers the element within its container. Negative values are possible. The initial value is 0. You can also use the em unit. This is relative to the element's font size: '1em' is equal to the size of the font in use.

Percentage values for margin on each side refer to the percentage of the box's alloted WIDTH (outer width). Say I specify margin-left and margin-right at 10%, the border is 1 px wide, and the content is currently 438px wide. Then the left and right margins are 55px: 55*2 + 1*2 + 438 = 550, and 10% of 550 is 55. The interesing thing is that margin-top will also be based off the same width (not height) calculation. All else being equal it too will be 55px for a 10% setting. Now, if remove margin-left and margin right, the content has more space to expand into the box (unless otherwise specified the box size is configured by the browser). The box is still the same size except the content now has a width of 548, plus 2px for the borders. So a 10% margin-top is still 55px. Specifying more margin will squeeze in the content. 

The padding properties describe how much space to insert between the border and the content (e.g., text or image). 


When specifying margin, padding and border, multiple arguments can be used:

	one value: all four border widths are set to that value
	two values: top and bottom border widths are set to the first value, right and left are set to the second
	three values: top is set to the first, right and left are set to the second, bottom is set to the third
	four values: top, right, bottom and left, respectively

At the start of a project it may be useful to just clean out all default margins and make everything box-sizing. It is also a good time to add in the font details.

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box
    }

    html {
        background-color: #ffffff;
        color: #555;
        font-family: 'Lato', 'Arial', sans-serif;
        font-weight: 300;
        text-rendering: optimizeLegibility; 
    }

(if Lato is not available - say there is no internet connection - then Arial is the first back up. Then it's sans-serif).
(font-weight: 300; is available since it's one of the customise font weights we choose at google fonts)
(text-rendering: optimizeLegibility; makes the text rendering a lot smoother).



CSS Syntax
------------------------------------------------


A CSS rule-set (or just 'rule') consists of a selector and a declaration block. For example:

h1 {
    color:blue; 
    font-size:12px;
}

Where h1 is the selector that points to the HTML element you want to style.

The declaration block contains one or more declarations separated by semicolons. Each declaration includes a CSS property name and a value, separated by a colon. 

The id selector allows the targeting of specific elements (use a # followed by the element's id):

#para1 {
    text-align: center;
    color: red;
}

<p id="para1">Hello World!</p>
<p>This paragraph is not affected by the style.</p>

While ids are often used for specific elements (which is not often good practice), class attributes selectors allow us to group elements. In the next example two different elements types are both styled by the smae code:

    .center {
        text-align: center;
        color: red;
    }

    <h1 class="center">Red and center-aligned heading</h1>
    <p class="center">Red and center-aligned paragraph.</p>


We can also specify that only certain HTML elements should be affected by a class.

    p.center {
        text-align: center;
        color: red;
    }

    <h1 class="center">This heading will not be affected</h1>
    <p class="center">This paragraph will be red and center-aligned.</p>

A specific element can also be styled by more than one class:

    p.center {
        text-align: center;
        color: red;
    }

    p.large {
        font-size: 300%;
    }

    <h1 class="center">This heading will not be affected</h1>
    <p class="center">This paragraph will be red and center-aligned.</p>
    <p class="center large">This paragraph will be red, center-aligned, and in a large font-size.</p>


Selectors can be grouped. If elements have the same values then you can clean up the CSS (any any unique values stay in separate blocks):

    h1, h2, p {
        text-align: center;
        color: red;
    }

    h1 {
        font-size: 200%;
    }


To change the style for the entire page use the body element selector:

    body {
        background-color: linen;
        font-size: 18px;
    }

This example also highlights the importance of CSS inheritance. Unless specified otherwise, all decendant elements will have a font size of 18 pixels.

Similary, the asterisk will affect all elements on our webpage. This example is a great way to override all element padding and margin defaults, as well as respecify the width property from content to border (see the box modal):

    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

Or you can target child elements of, say, a class: 

    .className>* {
        /*Set flex elements to fill the space equally*/
        flex-grow: 1;
    }

Pseudo Selectors, such as :hover, help distinguish states such as a move hover:

	div {
        width: 100px;
        height: 100px;
        background: red;
        transition: width 2s;
	}

	div:hover {
    		width: 300px;
	}



Targeting Specific Class Elements:

While several elments may share the same CSS rule we can still distinguish them with individual styling. Say we have three elements that share the class name "call-out". We want each call-out element to have many style features in common, such as padding and margin, but we want each to have a different background:

.call-out {
	padding: 20px;
	margin-bottom: 20px;
	flex: 1;
}

.call-out:nth-child(1) {background-color: #c0dbe2;}
.call-out:nth-child(2) {background-color: #cdf1c3;}
.call-out:nth-child(3) {background-color: #ccb9da;}


We can also target, say the last of these three, with a different right margin:

.call-out:last-child {
	margin-right: 0;
}


With spaces we can also apply a hierachy of classes using just one class name. Consider these two buttons:

    <a class="btn btn-full" href="#">I'm hungry</a>
    <a class="btn btn-ghost" href="#">Show me more</a>

We can assign all common CSS property values to a .btn {} rule and then supply sub rules for each button type.

    .btn {
        display: inline-block;
        padding: 10px 30px;
        font-weight: 300;
        text-decoration: none;
        border-radius: 200px;
    }

    .btn-full {
        background-color: #e67e22;
        border: 1px solid #e67e22;
        color: #ffffff;
    }

    .btn-ghost {
        border: 1px solid #e67e22;
        color: #e67e22;
    }

A CSS comment starts with /* and ends with */. Comments can also span multiple lines



How to use a Style Sheet
--------------------------------------------------

There are three ways to insert a style : external, internal, and inline.

With an external style sheet each page must include a reference to the external style sheet file inside the <link> element. The <link> element goes inside the <head> section:

<head>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>

An external style sheet can be written in any text editor. The file should not contain any html tags. The style sheet file must be saved with a .css extension.

An internal style sheet may be used if one single page has a unique style.

Internal styles are defined within the <style> element, inside the <head> section of an HTML page (as in the examples within the previous section).

An inline style may be used to apply a unique style for a single element. Just add the style attribute to the relevant element:

<h1 style="color:blue;margin-left:30px;">This is a heading.</h1>  [not that inline assignments use quotation marks ont he RHS of the assignment operator]

If the internal style is defined after the link to the external style sheet then the internal style sheet will be used. However, if the internal style is defined before the link to the external style sheet then the external will be used.



Eg1 internal used:

    <head>
        <link rel="stylesheet" type="text/css" href="mystyle.css">
        <style>
            h1 {
                color: orange;
            }
        </style>
    </head>



Eg2 external used:

    <head>
        <style>
            h1 {
                color: orange;
            }
        </style>
        <link rel="stylesheet" type="text/css" href="mystyle.css">
    </head>



Cascading order: 

1. Inline style (inside an HTML element)
2. External and internal style sheets (in the head section)
3. Browser default


You may also have enternal style Sheets you have downloaded, such as normalize.js (normalises styles accross all browsers). 

    <head>
        <link rel="stylesheet" type="text/css" href="./vendors/css/normalise.css">
        <link rel="stylesheet" type="text/css" href="./resources/css/style.css">
        <link href="https://fonts.googleapis.com/css?family=Lato:100,300,300i,400" rel="stylesheet">

        <title>Omnifood</title>
    </head>


Why does the order in which we place the scripts matter?

Our own script.js file should always be the last one. That's because of the dependencies we have in our code. For example, with jQuery, we use it in our script.js file., so it's a dependency. And we need to load that dependency before we can use it, of course. And that's why the jQuery should be loaded first. And the same of course applied to other external scripts.





Position
-------------------------------------------------

position: static - The default value for position. This basically says "let the browser lay this thing out without any special positioning". It will not react to the following properties: top, bottom, left, right, z-index.

position: relative - Allows you to position an element relative to it's static position using the offsets provided by the top, right, bottom and left properties, z-index. The element will remain in the natural flow of the page. It also makes the element positioned so that it will act as an anchor point for an absolutely positioned child.

position: fixed - The element will not remain in the natural flow of the page. It will position itself relative to the viewport(browser window, essentially) using the offsets provided by the top, right, bottom, left and z-index properties. Because it's positioned, it will act as an anchor point for an absolutely positioned child.

position: absolute - Allows you to position an element relative to it's first non statically positioned parent using the top, right, bottom, left and z-index properties. If there is no non-statically positioned parent, the <html> element will be used. The element will not remain in the natural flow of the page. It will position itself according to the closest positioned ancestor. Because it's positioned, it will act as an anchor point for an absolutely positioned child.

position: sticky 

Say you want to postion an element relative to a parent. Apply position: absolute on the div you want to position and then top, right, bottom, and left to control the exact positioning. However, if you just do this, you'll notice that the element positions itself relative to the <html> element. If you want to position it relative to something else (in your case, it's direct parent), you'll need to give that parent element a non-static position. Anything that's not position: static will work here (even another position: absolute) but in most cases, you likely want that parent element to just stay where it is without any special positioning. So in order to give that element "non-static positioning" without actually moving it from it's static position, you can actually give it position: relative, but don't specify any values for top, right, bottom, or left. This way you are positioning the element relative to it's static position by 0px.

Another example might be pushing one element to the right. For example we might have a blog post title, <h1>, and the date the blog post was written <p class="date">, both within a container <div class="blog-post">. And, we want the date to sit to the right of the title.

After positioning the container to relative, then:

    .date {
        position: absolute;
        top: 0px;
        right: 0px;
    }

So there is no difference between the right side of the parent container and data element.

Flexbox is the modern alternative (another option is float - see the section below).  

    .blogHead {
        /*Set the container to flex box*/
        display: flex;
        position: relative;
        border: 1px solid red;
        padding: 12px;
    }

    .blogHead>* {
        /*Set flex elements to fill the space equally*/
        flex-grow: 1;
    }

    .blogDate {
        text-align: right;
    }

    h1 {
        text-align: left;
    }


Note that other position related properties exist:

- right (left): defines the position of the element according to its right (left) edge.
- bottom (top): defines the position of the element according to its bottom (top) edge.


top examples:

- top: auto;  The element will remain in its natural position (default).
- top: 20px;   If the element is in position relative, the element will move downwards by the amount defined by the top value. If the element is in position absolute, the element will position itself from the top of the first positioned ancestor.







Display
--------------------------------------------------

The display property is the most important CSS property for controlling layout; it specifies if/how an element is displayed. The default display value for most elements is block or inline.

A block-level element always starts on a new line and takes up the full available width of the page (stretches out to the left and right as far as it can).

Examples of block-level elements:

	<div>
	<h1> - <h6>
	<p>
	<form>
	<header>
	<footer>
	<section>

An inline element does not start on a new line and only takes up as much width as necessary. This means that successive inline elements will sit alongside each other. Examples:

	<span>
	<a>
	<img>

(Using a span is thus a useful way to create in line styling for part of the inner HTML of a component).

Any height and width properties will have no effect.


Sometimes we want an inline element to have padding and margin properties (normally they don't). We can activate these options with display: inline-block;

display: none; is commonly used with JavaScript to hide and show elements without deleting and recreating them. The <script> element uses display: none; as default. You can also use visibility:hidden which means an element will not be seen but the layout does not change.

Some display values refer to inside elements, eg

    display: flow;
    display: table;
    display: flex;
    display: grid;


Border
-----------------------------------------------

The border property is a shorthand property for the following individual border properties:

	border-width
	border-style (required)
	border-color


Eg:

	border: 1px solid black;

The <border-width> value has these possible values:

'thin' | 'medium' | 'thick' | <length>


The border style properties refer to the <border-style> value type which is defined as follows:

	none | dotted | dashed | solid | double | groove | ridge | inset | outset


To round a border:
	border-radius: 5px;


To make sure the height really includes the padding and the border:

    box-sizing: border-box;

By using an invisible border, the border is generally invisible but this makes a differnce during hover.

    text-decoration: none;
    border-bottom: 4px solid transparant;

And so in :hover or :active we can then specify (looks cool):

    background-color: #8F5C2C;
    border-bottom: 4px solid #40A4C8;
    color: white;



width
-----------------------------------------------

The width CSS property specifies the width of an element. By default, the property defines the width of the content area. If box-sizing is set to border-box, however, it instead determines the width up to and including the border (so not the margin).

If width is set to auto then all the available horizontal space is used. If padding and/or margin is included, then all parts of the box, including the content adjust to fit.

If, instead, width is set at 100%, and then padding and a margin are set, then the element will spill over to the right. It is in this non-auto case that the width of an element does not include padding, borders, or margins. 

The min-width and max-width properties override the width property.


height
-----------------------------------------------

The height CSS property specifies the height of an element. By default, the property defines the height of the content area, which means the height of an element does not include padding, borders, or margins. If box-sizing is set to border-box, however, it instead determines the height of the border area. 

If height: auto; the element will automatically adjust its height to allow its content to be displayed correctly.

If height is set to a numeric value (like pixels, (r)em, percentages) then if the content does not fit within the specified height (of the parent element), it will overflow. How the container will handle the overflowing content is defined by the overflow property.


The min-height and max-height properties override height.


Alignment
--------------------------------------------------

Horizontal centering with css is easy. When the element to be centered is an inline element we use text-align center on its parent. When the element is a block level element we give it a width and set the left and right margins to a value of auto.

If you are trying to verically align text then don't set a width property. It just pushes the text around.

parent in flex box:

        display: flex;
        align-items: center;


div
--------------------------------------------------

<div> stands for divide, and is one of the most used elements in HTML.  


float
--------------------------------------------------
One alterative for lining up two divs, side by side, is to use float and width together. For example,

    .LHS_main_content {
        width: 75%;
        float: left;
    }

    .RHS_side_menu_or_links {
        width: 25%;
        float: right;
    }

Unlike flexbox we can still have a third div, like a footer just appear at the bottom without having to wrap up these first two elements in yet another div. 

However, now the footer needs to be told not to sit directly under the LHS side elements. Create a div just before the footer and give it the class name clearfix.

    <div class='clearfix'></ div>
    <footer .....

    .clearfix:after {
        content: "";
        display: table;
        clear: both;
    }

The clear property clears the float. The .clearfix class has the pseudo-element :after  because we want to properties, especially clear: both  (which does the real work of clearing the floats) to happen at the end of the element (after) on which we use the clearfix class. As for the other properties, there is no real explanation, this is just a "hack", which means that it solves the problem in a strange way. This (or in a slightly different version) is how everybody uses the clearfix.



[flexbox seems a lot easier to me! - and total divs are still the same. See this and another absolute positioning option in the position section, above].

Another way to use float is two push to items to one side. Say, in my footer I would like an image and then a name right next to it. Just give both the <img> and the <p> float: left . 


If you don't clear a float items begin to creep out of place or margin seem to disappear (inspect them in the dev tools. The highlight color will change to something like green). Supply parents of floating elements an extra class called clearfix and use this:

    .clearfix {
        zoom: 1;
    }

    .clearfix:after {
        content: '.';
        clear: both;
        display: block;
        height: 0;
        visibility: hidden;
    }



Buttons
--------------------------------------------------

If your button is made from an anchor/link, <a>, element then you will want to make sure it's style does not changed after a click.

    <a class="btn btn-full" href="#">I'm hungry</a>
    <a class="btn btn-ghost" href="#">Show me more</a>

 This requires the use of :visited. But, to lump this in with the default case, you will need the default pseudo selector, which is :link.

    .btn:link,
    .btn:visited {
        display: inline-block;
        padding: 10px 30px;
        font-weight: 300;
        text-decoration: none;
        border-radius: 200px;
    }

We also see that we line the buttons up with display: inline-block; and we don't want the underline to appear text-decoration: none;

You might also like to combine hover and active (when we are clicking on the button). In this case we want a darker color than the normal case. Transition is also a nice effect to make the change in state to hover more smooth (it takes multiple arguments; a time for each property you which to transition). The transition occurs as you move into and out of the relevant css rule. This example invovles two buttons with slightly different properties:

    .btn:link,
    .btn:visited {
        display: inline-block;
        padding: 10px 30px;
        font-weight: 300;
        text-decoration: none;
        border-radius: 200px;
        transition: background-color 0.2s, border 0.2s, color 0.2s;
    }

    .btn-full:link,
    .btn-full:visited {
        background-color: #e67e22;
        border: 1px solid #e67e22;
        color: #ffffff;
        margin-right: 15px;
    }

    .btn-ghost:link,
    .btn-ghost:visited {
        border: 1px solid #e67e22;
        color: #e67e22;
    }

    .btn:hover,
    .btn:active {
        background-color: #cf6d17; 
    }

    .btn-full:hover,
    .btn-full:active {
    border: 1px solid #cf6d17;
    }

    .btn-ghost:hover,
    .btn-ghost:active {
        border: 1px solid #cf6d17;
        color: #fff;
 }



Another example of a a button formed from a link, but made from an image:

    <a href="#" class="btn-app"><img src="resources/img/download-app.svg" alt="App Store Button"></a>
    <a href="#" class="btn-app"><img src="resources/img/download-app-android.png" alt="Play Store Button"></a>




px vs %
--------------------------------------------------

So, we use px and % in different situations. We use percentages more for "layout" elements, which means elements that define the layout and that we want to change according to the screen width. Also, percentages are most useful for defining horizontal distances between elements, such as widths  or margin-left  or margin-right , not vertical distances, because responsive web design works with screen widths (horizontal). In other words, everything that we want to change based on the screen width when the screen becomes smaller, should be defined in %.

Also, font-sizes are always defined in %, except for the base font-size defined for the body element, so that we can easily change font-sizes for smaller screen sizes.

We use px to define some margins and paddings, and sometimes to define smaller distances and distances that doesn't need to change when the screen changes. For the paddings, please note that we can only use px here thanks to box-sizing: border-box; , which ensures that the box width (defined in %) always stays the same no matter how much padding we add inside of it.


Links
--------------------------------------------------

    a:link,
    a:visited {
        color: #e67e22;
        text-decoration: none;
        padding-bottom: 1px;
        border-bottom: 1px solid #e67e22;
        transition: border-bottom 0.2s, color 0.2s;
    }

    a:hover,
    a:active {
        color: #555;
        border-bottom: 1px solid transparent;/* since we have removed text decoration above, and use our border, transparant is the easy way to remove it*/
    }


Flexbox
--------------------------------------------------


see "Flexbox Tutorial (CSS): Real Layout Examples" in youtube.


The CSS rule for the parent div should include 

	display: flex;


Then, if you want a child element to have a share of all the remaining space, it should have a relative sharing ratio. If all elements are to equally share the main container then each would have 

	flex: 1;

If there were three elements and one was to take up half of the main container then the dominant element would have flex: 2;  while the remaining two would have flex:1;

If we had two elements, but we only wanted one to expand and fill the remaining space, the this larger element would use flex:1 while its sibling would stay quiet on flex value. It will get its normal auto size.



Order:


We can order elements within a flex container without having to cut and paste child divs in the html (which we may not want to do for search engine purposes). For the first element use:

 order: 1; 

And the second used order: 2;  etc. 

In this CSS example we have a container div with the class name "column-layout". We make it a flex container with the CSS value display: flex. Within it are three children. One is the main column, which we would like in the middle and with much more space, and then two small side bars. One side bar is on the left and one on the right:

	.column-layout {

		max-width: 1300px;
		backfround-color: #FFF;
		margin: 40px auto 0 auto;
		line-height: 1.65;
		padding: 20px 50 px;
		display: flex;
	}

	.main-column {
		flex:3;
		order: 2;
	}

	.sidebar-one {
		flex: 1;
		order: 1;
	}

	.sidebar-two {
		flex: 1;
		order: 3;
	}






Uniform vs Non-Uniform Height:


One of the strengths of flex is equal heights. For example we may have three child elements arrange across the page. Each child has a different amount of text but they will all be the same height. However, should we not want this property we can use the following CSS value in the parent CSS rule:

	align-items: flex-start;


The three elements will be aligned across the top, or start of the flex container, and drop to different lengths. If we would like the three elements to be flush along the bottom of the parent container then we use:

	align-items: flex-end;

To centre the three elements around the middle of the parent flex container, we can use:

	align-items: center;

(The default, which was always there, was align-items: stretch; )




Margins:

In non-flex CSS we could just target individual margins for each child element. However, there is a flex approach. In the child CSS rule change flex: 1 to a wdith percentage (note if you assign both padding and width CSS values ,then you should also use box-sizing: border-box so that the math stays as simple as possible):


.call-out {
	padding: 20px;
	box-sizing: border-box;
	margin-bottom: 20px;
	width: 30%   
}

(An alternative to width, and really the proper flexbox way, is to use flex-basis: 30%)

Since there are 3 elements we now have used 90% of the available space. This leaves 10% to evenly divide up as margins. We do this by targeting the parent element with a justify content value:

.call-outs-container {
	max-width: 1400px;
	margin: 40px auto 0 auto;
	display: flex;
	justify-content: space-between;
}

The default value for justify-content is start. This will psuh all three children to the left and leave the 10% at the end, or right. Using 'end' as a value will move the three elements to the right, and consequently leave the 10% of background color on the left, or start. The value "center" will align the content in the midle of the parent container, leaving 5% background on each side.




Layout for Small Screens like Tablets and Smart Phones:

For a quick idea as to how your page will look on a small screen just resize the browser window. One problem is that child text ends up looking very squeezed if the children are left felxed accross the screen. Lines of text become only a few words across. For small screens we need paragraphs to sit on top of each other.

If we remove the flex and justify parent values, we can then reintroduce them with a media query that targets screen sizes over 900 pixels:

	.call-outs-container {
		max-width: 1400px;
		margin: 40px auto 0 auto;
		display: flex;
		justify-content: space-between;
	}

	.call-out {
		padding: 20px;
		box-sizing: border-box;
		margin-bottom: 20px;
		width: 30%   
	}


	@media (min-width: 900px) {
		.call-outs-container {
			display: flex;
			justify-content: space-between;
	}

So the flex properties will only apply to a large screen now.



Multiple Rows of Items on Smaller Screens:


Say we have a number of elements in a row across a flex container, and each of these elements is of a fixed size (eg 150px x 100px). As the screen size decreases flex will narrow the margin between each elements but as the screen becomes very small flex becomes stubborn. It will refuse to push elements into another row. Instead the elements will begin to merge. We can tell flexbox to make multiple rows with a the flex-wrap property in the parent container. By default it is set to 'nowrap'. In the parent CSS rule use:

	flex-wrap: wrap;


Simple Centering:

In this example we want to centre some text, "Center Me Please" both vertically and horizontally within a box (with a class name of "banner").

original html:

<div class="banner">
	div class="center-me">Center Me Please</div>
<div>


original CSS:


.banner {
	height: 400px;
	max-width: 700px;
	margin: 40px auto 40px auto;
	background-color: #2a2a2a;
}

.center-me {
	color: #FFF;
	font-size: 50px;
}

We are not going to fix the width and height values of the text. It will dynammically change as required (in the past centering content with an unkown width and height has been notoriously tricky). Without flex box we could have used text-align: center to horizontally center the text. 'margin: 0 auto;" has been around a long time. It adds no vertical margin set the horizontal margins to auto. However the vertically centering would have still been tricky.

With flexbox we tell the parent container to use flex box. We then use "margin: auto" in the child CSS rule to auto margin in all directions. Flexbox works very well with this property.

.banner {
	height: 400px;
	max-width: 700px;
	margin: 40px auto 40px auto;
	background-color: #2a2a2a;
	display: flex;
}

.center-me {
	color: #FFF;
	font-size: 50px;
	margin: auto;
}



Nesting and Changing Direction:


We can make child containers flex containers as well:

	.parent {
		display: flex;
	}

	.some-other-child {
		flex: 1;
	}

	.child {
		flex: 1;
		display: flex;
		flex-direction: column; 
	}

	.grand-child-1 {
		flex: 1;	
	}

	.grand-child-1 {
		flex: 1;	
	}


By default flex-direction is set to row.

So now we have two children side by side, and then two grandchildren, on the right hand side, with one on top of the other. We have made a nice mixture of rows and columns.



NavBar Example
---------------------------------------------

    <nav>
        <div class="row">
            <img src="./resources/css/img/logo-white.png" alt="Omnifood logo" class="logo">
            <ul class="main-nav">
                <li><a href="#">Food delivery</a></li>
                <li><a href="#">How it works</a></li>
                <li><a href="#">Our cities</a></li>
                <li><a href="#">Sign up</a></li>
            </ul>
        </div>
    </nav>

    .logo {
        height: 100px;
        width: auto;
        float: left;
        margin-top: 20px;
    }

    .main-nav {
        float: right;
        list-style: none;
        margin-top: 55px;
    }

    .main-nav li {
        display: inline-block;
        margin-left: 40px;
    }

    .main-nav li a:link,
    .main-nav li a:visited {
        padding: 8px 0;
        color: #fff;
        text-decoration: none;
        text-transform: uppercase;
        font-size: 90%;
        border-bottom: 2px solid transparent;
        transition: border-bottom 0.2s;
    }

    .main-nav li a:hover,
    .main-nav li a:active {
        border-bottom: 2px solid #e67e22;
    }




Toolbar Example
-----------------------------------------

In this styling we want a fix positon at 0,0 so that it always sits at the top. Flex helps the sub elements sit nicely with each other with space between, and then align-items handles vertical alignment. We set a z-index less than that of the backdrop. We also make sure any navigation items span the full height of the toolbar.

    .Toolbar {
        height: 56px;
        width: 100%;
        position: fixed;
        top: 0;
        left: 0;
        background-color: #703B09;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 20px;
        box-sizing:  border-box;
        z-index: 90;
    }

    .Toolbar nav {
        height: 100%
    }


For a logo image in the toolbar we might like to use box sizing so that padding is included in the total height.

    .Logo {
        background-color: white;
        padding: 8px;
        height: 80%;
        box-sizing: border-box;
        border-radius: 5px;
    }

    .Logo img {
        height: 100%;
    }



Side Draw Example
-------------------------------------------------------

    .SideDrawer {
        position: fixed;
        width: 280px;
        max-width: 70%;
        height: 100%;
        left: 0;
        top: 0;
        z-index: 200;
        background-color: white;
        padding: 32px 16px;
        box-sizing: border-box;
        transition: transform 0.3s ease-out;
    }

    @media (min-width: 500px) {
        .SideDrawer {
            display: none;
        }
    }

    .Open {
        transform: translateX(0);
    }

    .Close {
        transform: translateX(-100%);
    }

We see a fixed position on the top left, a z-index above the backdrop, a transition property to react to changes of the transform property and animate them over 300 ms with a ease-out timing function. The transform property is affected by the Open and Close classes. 

The media query is for larger devices, which do not display a side drawer.

The Open and Close classes are conditionally activated in React. They are responsible for animation. Open shifts the panel to the 0,0 fixed positon defined above. Close shifts it all to the left.

Now we want to insert a toogle button that consists of three vertical lines. In the component make three divs and then:

    .DrawerToggle {
        width: 40px;
        height: 100%;
        display: flex;
        flex-flow: column;
        justify-content: space-around;
        align-items: center;
        padding: 10px 0;
        box-sizing: border-box;
        cursor: pointer;
    }

    .DrawerToggle div {
        width: 90%;
        height: 3px;
        background-color: white;
    }

    @media (min-width: 500px) {
        .DrawerToggle {
            display: none;
        }
    }



Modals in React
---------------------------------------------------

Create a new UI folder under components (for UI components) and then create a sub folder called Modals. Also create another subfolder named Backdrop. We create a separate backfrop feature because we may want to use it elsewhere, perhaps in the sidebar.

It's just a normal functional component with special styling:

    .Modal {
        position: fixed;
        z-index: 500;
        background-color: white;
        width: 70%;
        border: 1px solid #ccc;
        box-shadow: 1px 1px 1px black;
        padding: 16px;
        left: 15%;
        top: 30%;
        box-sizing: border-box;
        transition: all 0.3s ease-out;
    }

    @media (min-width: 600px) {
        .Modal {
            width: 500px;
            left: calc(50% - 250px);
        }
    }

At a higher level we insert the modal and pass on some methods that allow us to later check if the modal should be open, and update that state. We also include the contents of the modal (here <OrderSummary>) as props.children.

    <Modal show={this.state.purchasing} modalClosed={this.purchaseCancelHandler} >
        <OrderSummary ingredients={this.state.ingredients} />
    </Modal>
    <BuildControls 
        // ...
        ordered={this.purchaseHandler} />

(ordered={this.purchaseHandler} feeds into the order button)


The associated backdrop usess 100% of the width and height, is fixed (so it's not scrollable), and has a z-index so that it sits between the modal and the regular components.

    .Backdrop {
        width: 100%;
        height: 100%;
        position: fixed;
        z-index: 100;
        left: 0;
        top: 0;
        background-color: rgba(0, 0, 0, 0.5);
    }

    import React from 'react';
    import classes from './Backdrop.css';

    const backdrop = (props) => (
        props.show ? <div className={classes.Backdrop} onClick={props.clicked}></div> : null
    );

    export default backdrop;

We can also use the CSS transition property within a conditional inline style object (vh is the unit for vertical height). This gives us some animation.
There are a number of places this can be imported. To save on making stateful components we will just place it inside the modal component. 

    import React from 'react';
    import classes from './Modal.css';
    import Aux from '../../../hoc/Auz';
    import Backdrop from '../Backdrop/Backdrop'

    const modal = (props) => (
        <Aux>
            <Backdrop show={props.show} clicked={props.modalClosed}/>
            <div 
                className={classes.Modal}
                style={{
                    transform: props.show ? 'TranslateY(0)' : 'TranslateY(-100vh)',
                    opacity: props.show ? '1': '0'
                }}>
                {props.children}
            </div>
        </Aux>
    );

    export default modal;



Using Media Queries to Disable an Element
----------------------------------------------

After setting up a media-query verison of css classes, go through and delete any duplicates. Media queries are later merged with the original classes. 

With media queries and props we can diable entire sub features within certain media based parents (ie we have a side drawer that only exists for mobile devices and so we don't want any tool bar navigation items to appear):

    <nav className={classes.DesktopOnly}>
        <NavigationItems />
    </nav>

    @media (max-width: 499px) {
        .DesktopOnly {
            display: none;
        }
    }



Lists
-----------------------------------------------

If you don't want list items to have default values:

    list-style: none;

To ensure your specified height has an effect in a list:

    display: block;




Pseudo-elements generated by :before and :after
-----------------------------------------------

With :before and :after we can create elements purely with CSS. 

In this example we create a custom orange underline for h2 elements:

    h2:after {
        display: block;
        height: 2px;
        background-color: #e67e22;
        content: " ";
        width: 100px;
        margin: 0 auto;
        margin-top: 30px;
    }

We must always specify a content property. But, like here, we can leave it blank since we don't want any text in this element.





Typography
-----------------------------------------------

Typography is the art and technique of arranging type to make written language readable and beautiful. It is therefore essential for web design.

Flat design is the modern norm. Buttons and icons do not have shadding or 3-d like features.

15-25 px font size for regular text. 

Headlines have no real font size limits, eg 60px, or even 90px, but at the larger end you will won't to decrease the font-weight of the text. The text will then detract less from other elements, and be more slim-lined and modern.

Use line spacing of between 120-150% of the font size. This makes text easier to read. 45-90 characters per line is the optimal length to read.

.long-copy {
    line-height: 145%;
    width: 70%; /* limits the characters per line but ruins centering*/
    margin-left: 15%; /*fixes the centering problem. Given 70% above, 15 + 15 is the remainder */
}

(long-copy is for our longer text paragraphs, where 'copy' has the old usage meaning text)


Choose good looking fonts. Sans serif typefaces are more netrual, clean and clear. Use these on most modern websites. You might want serif fonts for traditional purposes, storytelling and long reading.

Google fonts is a good free resource. Some good sans fonts include
    - open sans
    - lato 
    - railway
    - monsterrat
    - PT sans

Some good serif fonts include:
    - Cardo
    - Merriweather
    - PT serif

Overall, however, choose a font that best represents the feel of your website. And if you are a beginner, use only one typeface. There is a section in this e-book that helps you pair fonts file:///C:/Users/chamilton/Downloads/website-e-bookv2.0.pdf .

Here we see the styling for a headling element that sits in the middle of the screen above a large image:

    h1 {
        margin: 0;
        color: #ffffff;
        font-size: 240%;
        font-weight: 300;
        text-transform: uppercase;
        letter-spacing: 1px;
        word-spacing: 4px;
    }

The white text color is for contrast with the transparant black background on the image (see below on working with images). font-size is relative to the globally defined font-size, so will automatically update when the global value changes. Because it's quite a large font, we use font-weight to slim it down (we imorted this custom font weight from google fonts). To make it look nice we also transform the text to uppercase and give the letters and words some spacing.



Color
-------------------------------------------

This is one of the most difficult parts of web design. You do not want distracting colors. They look out of place and make the website look messy.

<<<<<<< HEAD
Use just one base/main color for your design. That is, any colour except black, white, or any shade of grey. You then create a nice color-palete by using related shades (there are tools for this such as https://flatuicolors.com or http://www.0to255.com/ - the later can give us shade variations). 
=======
Use just one base/main color for your design. That is, any colour except black, white, or any shade of grey. You then create a nice color-palete by using related shades (there are tools for this such as https://flatuicolors.com or http://www.0to255.com/ - the later can give us shade variations).  
>>>>>>> 04f3a1e5117a010cbc71abdca845ab0010ed3626

If you really want to mix up multiple colours use a color-wheel. They make use of color theory to make good combinations for you.

Use the main color to draw attention to the main elements on your web page. In fact, if you are not sure which colors to use, just keep a stronger color for the most important elements, such as "call to action" buttons. 

Never use black in your design. Black almost never appears in the real world so using it doesn't feel natural.

Because colours can convey emotion, carefully choose the right colors.
    - red: strength, passion, excitment. Brighter tones are more energetic while lighter tones are more powerful and elegant.
    - orange draws attention without being as over powering as red. Associated with cheerfulness, freidnlyness, courage and creativity. 
    - yellow is energetic and gives the feeling of happiness. It assoicates with curosity, brightness and intelligence.
    - green: harmony, nature, life, money and health. Can also have a balancing affect.
    - blue: patience, peace, trust-worthyness, and stability. This is one of the most beloved colors, especially by men. This is associated with profesisonalism, trust, and honour.
    - purple: power, nobility wisdom, luxury, mystery and wealth.
    - pink: romance, passivity, care, peace, affection, etc.
    - brown: relaxation, earthiness, nature, comfort, reliability and confidence. 

One nice trick is to use a very subtle background color in one section and leave surroundign sections with a white background.

    .section-steps {
        background-color: #f4f4f4;
    }

    

Working with Images
------------------------------

Image heavy web sites convert better. Here we learn how to put text over images. 

Putting text directly on an image only works if the image is dark and the text is light. Otherwise you do not have enough contrast between the text and the image. 

The most common solution is to overlay the image with a transparant color. Then place your text on the image. Black is the most common color but many options are available - use colors that make sense (see the section above). Color gradients are another option. Check out the course e-book. 

The third option is to put some text in an opaque box somehwere in the image. Sometimes the box will be transparent. 

Another option is image blur. Blur the background image and then apply your text.Similarly, you can use an out of focus area to apply the text. In this way you help bring focus on the important parts of the image. The trick, however, is too keep the text position over all screen sizes.

One last idea is a floor fade. The bottom of the image fades to dark and the text is applied in this area.

Sometimes background-attachment: fixed; is nice for background images. Note that this may not work on iOS devices. Use background-attachment: scroll; instead. Alternatively, you could just ignore background-attachment: fixed;  altogether for smaller screen widths.

Here is an example of setting a full screen image within the header element holding a div of class=".hero-text-box". We want the header to sit nicely centered over a large, full screen backkground image.

    <header>
        <div class="hero-text-box">
            <h1>Goodbye junk food. Hello super healthy meals.</h1>
            <a href="#">I'm hungry</a>
            <a href="#">Show me more</a>
        </div>
    </header>


    header {
        background-image: linear-gradient(rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url(./img/hero.jpg);
        background-size: cover;
        background-position: center;
        height: 100vh;
    }

    .hero-text-box {
        position: absolute;
        width: 1140px;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }

header:

A height of 100vh means use 100% of the vertical height of the image. This along with a center position means that as the view port resizes so does the image. The background-size property also has a value of cover, otherwise you don't see the background image at all.

background-image essentially takes two arguments/images. The first is a linear gradient that transitions from one color to another (or a 2nd image url). We have it transition to the same thing (transparant black) so that it is all transparant black. This is what will give our text contrast with the background image.

The transform property in the hero-text-box allows us to readjust the absolute positioning into the center of the screen. The transform property applies a 2D or 3D transformation to an element. This property allows you to rotate, scale, move, skew, etc., elements.


In this example we make a grid of images with transitions on darkness and scale:

    .meals-showcase {
        list-style: none;
        width: 100%;
    }

    .meals-showcase li {
        display: block;
        float: left;
        width: 25%; /* 4 images wide to give 100%*/
    }

    .meal-photo {
        width: 100%; /* 100% width of parent */
        margin: 0;  /* despite over- riding at the * rule, the normalise library over-rides it */
        overflow: hidden;  /* since we scale at 115% we need to tidy up overflow */
        background-color: black;  /* this mixed with opacity of 0.7 - see below - makes the images darker */
    }

    .meal-photo img {
        opacity: 0.7;  /* allows the parent's black background to darken the image*/
        width: 100%;
        height: auto;
        transform: scale(1.15);
        transition-duration: 0.5s;
    }

    .meal-photo img:hover {
        opacity: 1;
        transform: scale(1.03);  /* On mouseover images springs back into shape and lightens up*/
    }


You can use text-align for all inine andinline block elements, eg icons and images.


Working with Icons
--------------------------------------
Icons have a lot of power, but they can also cause confusion when poorly used.

Use them to show features of your website or products that you are selling. Or perhaps steps users must follow to reach some goal. You can also use icons for actions and links.

Rules:
    - Icons should be instantly recognisable
    - Label your icons.
    - Icons should not take center stage in your design. They play a supporting role.

Icons can be static images or vector fonts. Vector fonts scale smoothly when resized. Use fonts.

The ebook lists free icon sets.

Example:

    .icon-big {
        font-size: 350%;
        display: block;
        color: #e67e22;
        margin-bottom: 10px;
    }

So, like text, we can change the color of the icon with just the color attribute. Similarly, we can also make them bigger/smaller with font-size. A block display is also useful in this case. Forcing a line break often gives icons the proper space if they are over a paragraph. 

However in other cases you might have an icon sitting next to some text. You will also want to line the icon up with the text:

    .icon-small {
        display: inline-block; /* allows us to use the width property */
        width: 30px;
        text-align: center;
        color: #e67e22;
        font-size: 120%;
        margin-right: 10px;
        
        /* secrets to align text and icons*/
        line-height: 120%;
        vertical-align: middle;
        margin-top: -4px;  /*pull icons up*/
    }




Whitespace
--------------------------------------

Every piece of good design uses white space well. It creates a clean and simple look and feel, but also communicates how elements relate to each other. It is closely related to the idea of 'visual heirachy'; how your content is organised.  
    - Put whitespace between your elements
    - Put whitespace between groups of elements
    - Put whitespace between sections
    - But don't exaggerate; elements can lose their relationship.

To define your heirachy
    - Define where you want your audience to look first. 
    - Establish a flow that corresponds to your content's message.
    - Use whitespace to build that exact flow.



Define Your Project
------------------------------------------

- Define the goal of the Project, eg selling something, releasing a book, show what a company does and where it is located, have people sign up on a plan, etc.
- Define your audience -  the typical user, eg 'busy people who don't have time to cook or don't want to'.

- Define the nagviagtion and site structure
- After having a good think about the design, sketch yoru ideas before you start designing.
- Make many sketches but don't spend a long time making them perfect.
- Never start designing without an idea of what you want to build. Get inspiration.
- Once you have a sketch, use the tips above (color palate, font, whitespace, icons, videos, images, etc,) to further design. 
    - Start thinking about visual heirachy
    - This is the 'Content First' approach. Don't just fill a page with content, put consider the content first and design around it.
    - Define the navigation and site structure.
- Continue to design in the browser by adjusting HTML and CSS.
- Optimise performance and for search engines.
- After launch, monitor user behaviour and adjust your site as necessary.
- Update content regularly to show that this is a living site. One way to do this is blogs.



Responsive Web Design
-----------------------------------------
Web pages on any screen size should be easy to navigate. You should not have to zoom in and out to use features.

Google prioritises mobile friendly web pages in it's search results.

The three main ingredients of responsive design are:

    - Fluid grid: all layout elements are sized in relative units, such as percentages, instead of absolute units like pixels.
    - Flexible images: are also sized in relative units
    - Media queries: alow us to specify different CSS style rules for different browser widths.

One option is to download "responsive grid system". Other options include bootstrap or wordpress. While it's useful to at least know how to use bootstrap, for now the simpler respoive grid is often enough.

Responsive is organised into rows and columns of a width relative to the browser window. If the screen becomes quite narrow the collumns stack. It's useful to set up some values for our rows:

    .row {
        max-width: 1140px;
        margin: 0 auto;
    }

(Be careful with any styles imported from this library. You have to override them.)


One area of interest is font-size. Say we have a global fon-size in px. Then, say for <h1> we might specify a percentage:

    h1 {
        font-size: 200%;
    }

Then should we change the global font-size change, then so will our h1 font size. Ie, the font size in this element is relative to the base size here:

    html {
        background-color: #ffffff;
        color: #555;
        font-family: 'Lato', 'Arial', sans-serif;
        font-size: 20px;
        font-weight: 300;
        text-rendering: optimizeLegibility;
    }


Quotes
---------------------------------------

Example of image (profile pic) next to the quote:

    <blockquote>
        Inexpensive, healthy and great-tasting meals, delivered right to my home. We have lots of food delivery here in Lisbon, but no one comes even close to Omifood. Me and my family are so in love!
        <cite><img src="resources/img/customer-2.jpg">Joana Silva</cite>
    </blockquote>


